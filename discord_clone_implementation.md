# Discord Clone Project Implementation Guide

## Project Overview

This project aims to create a full-stack Discord-like chat application using React for the frontend and Node.js/Express for the backend, with Sequelize ORM for SQL database integration. The application will support real-time messaging using Socket.IO, user authentication, channel creation and management, and message persistence.

## Technology Stack

### Backend
- **Runtime**: Node.js
- **Framework**: Express.js
- **Database**: SQL (via Sequelize ORM)
- **Authentication**: JSON Web Tokens (JWT)
- **Real-time Communication**: Socket.IO
- **Testing**: Jest

### Frontend
- **Framework**: React
- **Build Tool**: Vite
- **State Management**: React Context API or Redux
- **Styling**: CSS Modules or Tailwind CSS
- **HTTP Client**: Axios
- **Testing**: React Testing Library

## Project Structure

### Backend (/backend)

#### Configuration (/config)
- **db.js**: Sequelize database configuration
  - Establish connection to the SQL database
  - Configure connection pool settings
  - Handle database authentication

#### Models (/models)
- **index.js**: Sequelize model loader
  - Import and initialize all models
  - Establish associations between models
  - Export initialized models
  
- **User.js**: User model
  - Fields: id, username, email, password (hashed), avatar, status, createdAt, updatedAt
  - Methods: authenticate, generateJWT, etc.
  
- **Channel.js**: Channel model
  - Fields: id, name, description, isPrivate, createdAt, updatedAt
  - Associations: belongsTo User (creator), hasMany Messages
  
- **Message.js**: Message model
  - Fields: id, content, attachment, channelId, userId, createdAt, updatedAt
  - Associations: belongsTo User, belongsTo Channel

#### Controllers (/controllers)
- **authController.js**: Authentication controller
  - register(): Create new user
  - login(): Authenticate user and generate JWT
  - getMe(): Get current user details
  - updateProfile(): Update user profile information
  
- **channelController.js**: Channel controller
  - createChannel(): Create a new channel
  - getChannels(): Get all accessible channels
  - getChannelById(): Get specific channel details
  - updateChannel(): Update channel details
  - deleteChannel(): Delete a channel
  
- **messageController.js**: Message controller
  - createMessage(): Create a new message
  - getMessages(): Get messages for a channel
  - updateMessage(): Update a message
  - deleteMessage(): Delete a message

#### Routes (/routes)
- **authRoutes.js**: Authentication routes
  - POST /api/auth/register
  - POST /api/auth/login
  - GET /api/auth/me
  - PUT /api/auth/profile
  
- **channelRoutes.js**: Channel routes
  - POST /api/channels
  - GET /api/channels
  - GET /api/channels/:id
  - PUT /api/channels/:id
  - DELETE /api/channels/:id
  
- **messageRoutes.js**: Message routes
  - POST /api/channels/:channelId/messages
  - GET /api/channels/:channelId/messages
  - PUT /api/messages/:id
  - DELETE /api/messages/:id

#### Socket (/socket)
- **socketHandler.js**: Socket.IO event handlers
  - Connection/disconnection handling
  - Join/leave channel events
  - Real-time message broadcasting
  - User status updates
  - Typing indicators

#### Middleware (/middleware)
- **authMiddleware.js**: Authentication middleware
  - verifyToken(): Validate JWT from request headers
  - attachUser(): Attach user object to request
  - requireAuth(): Block unauthenticated requests

#### Migrations (/migrations)
- Auto-generated by Sequelize CLI
- Database schema version control

#### Seeders (/seeders)
- Optional test data generation scripts
- Populate database with initial data for development

#### Root Files
- **server.js**: Main application entry point
  - Express setup
  - Middleware configuration
  - Route registration
  - Socket.IO initialization
  - Error handling
  
- **.env**: Environment variables
  - Database connection string
  - JWT secret
  - Port configuration
  - Environment flags (development/production)
  
- **package.json**: Project metadata and dependencies

### Frontend (/frontend)

#### Public (/public)
- **index.html**: HTML entry point

#### Source (/src)

##### Assets (/assets)
- Images, icons, and other static resources

##### Components (/components)
- **Layout/**: 
  - Sidebar.jsx: Channel and direct message list
  - ChatArea.jsx: Message display and input area
  - UserPanel.jsx: User information and settings
  
- **UI/**: 
  - Button.jsx: Reusable button component
  - Input.jsx: Reusable input component
  - Modal.jsx: Reusable modal component
  
- **Auth/**:
  - LoginForm.jsx: User login form
  - RegisterForm.jsx: User registration form
  
- **Channel/**:
  - ChannelList.jsx: List of available channels
  - ChannelItem.jsx: Individual channel item
  - CreateChannelModal.jsx: New channel creation form
  
- **Message/**:
  - MessageList.jsx: List of messages
  - MessageItem.jsx: Individual message display
  - MessageInput.jsx: Message composition area

##### Pages (/pages)
- **LoginPage.jsx**: Login page
- **RegisterPage.jsx**: Registration page
- **MainPage.jsx**: Main application page (after login)
- **SettingsPage.jsx**: User settings page

##### Services (/services)
- **authService.js**: Authentication API calls
- **channelService.js**: Channel API calls
- **messageService.js**: Message API calls
- **socketService.js**: Socket.IO connection and event management

##### Root Files
- **App.jsx**: Main React component
- **index.js**: React application entry point
- **App.css**: Global styles

## Implementation Tasks

### Database Setup
1. Configure Sequelize to connect to your SQL database
2. Design and implement database models (User, Channel, Message)
3. Set up model associations
4. Create initial migrations

### Backend Implementation
1. Set up Express server with middleware
2. Implement user authentication (registration, login)
3. Implement JWT-based authentication
4. Create RESTful API endpoints for channels and messages
5. Set up Socket.IO for real-time communication
6. Implement error handling

### Frontend Implementation
1. Set up React with Vite
2. Create component structure
3. Implement authentication UI (login/register forms)
4. Create main UI layout (sidebar, chat area)
5. Implement channel listing and creation
6. Implement real-time messaging
7. Connect Socket.IO for real-time updates
8. Style the application

## API Endpoints

### Authentication
- `POST /api/auth/register`: Register a new user
  - Request: `{ username, email, password }`
  - Response: `{ user, token }`
  
- `POST /api/auth/login`: Login existing user
  - Request: `{ email, password }`
  - Response: `{ user, token }`
  
- `GET /api/auth/me`: Get current user profile
  - Headers: `Authorization: Bearer {token}`
  - Response: `{ user }`
  
- `PUT /api/auth/profile`: Update user profile
  - Headers: `Authorization: Bearer {token}`
  - Request: `{ username, avatar, status }`
  - Response: `{ user }`

### Channels
- `GET /api/channels`: Get all accessible channels
  - Headers: `Authorization: Bearer {token}`
  - Response: `{ channels: [...] }`
  
- `POST /api/channels`: Create a new channel
  - Headers: `Authorization: Bearer {token}`
  - Request: `{ name, description, isPrivate }`
  - Response: `{ channel }`
  
- `GET /api/channels/:id`: Get channel details
  - Headers: `Authorization: Bearer {token}`
  - Response: `{ channel }`
  
- `PUT /api/channels/:id`: Update channel details
  - Headers: `Authorization: Bearer {token}`
  - Request: `{ name, description, isPrivate }`
  - Response: `{ channel }`
  
- `DELETE /api/channels/:id`: Delete a channel
  - Headers: `Authorization: Bearer {token}`
  - Response: `{ success: true }`

### Messages
- `GET /api/channels/:channelId/messages`: Get channel messages
  - Headers: `Authorization: Bearer {token}`
  - Query params: `{ limit, offset }`
  - Response: `{ messages: [...], hasMore }`
  
- `POST /api/channels/:channelId/messages`: Create a new message
  - Headers: `Authorization: Bearer {token}`
  - Request: `{ content, attachment }`
  - Response: `{ message }`
  
- `PUT /api/messages/:id`: Update a message
  - Headers: `Authorization: Bearer {token}`
  - Request: `{ content }`
  - Response: `{ message }`
  
- `DELETE /api/messages/:id`: Delete a message
  - Headers: `Authorization: Bearer {token}`
  - Response: `{ success: true }`

## Socket.IO Events

### Server Events (Emitted by server)
- `connect`: Server acknowledges connection
- `disconnect`: Server confirms disconnection
- `channel:join`: User joined a channel
- `channel:leave`: User left a channel
- `message:new`: New message received
- `message:update`: Message was updated
- `message:delete`: Message was deleted
- `user:typing`: User is typing
- `user:status`: User status changed

### Client Events (Emitted by client)
- `channel:join`: Join a channel
- `channel:leave`: Leave a channel
- `message:send`: Send a new message
- `message:edit`: Edit a message
- `message:delete`: Delete a message
- `typing:start`: User started typing
- `typing:stop`: User stopped typing
- `status:update`: Update user status

## Database Schema

### Users Table
```sql
CREATE TABLE Users (
  id INTEGER PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(50) NOT NULL UNIQUE,
  email VARCHAR(100) NOT NULL UNIQUE,
  password VARCHAR(100) NOT NULL,
  avatar VARCHAR(255),
  status ENUM('online', 'idle', 'dnd', 'offline') DEFAULT 'online',
  createdAt DATETIME NOT NULL,
  updatedAt DATETIME NOT NULL
);
```

### Channels Table
```sql
CREATE TABLE Channels (
  id INTEGER PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  isPrivate BOOLEAN DEFAULT FALSE,
  creatorId INTEGER NOT NULL,
  createdAt DATETIME NOT NULL,
  updatedAt DATETIME NOT NULL,
  FOREIGN KEY (creatorId) REFERENCES Users(id) ON DELETE CASCADE
);
```

### Messages Table
```sql
CREATE TABLE Messages (
  id INTEGER PRIMARY KEY AUTO_INCREMENT,
  content TEXT NOT NULL,
  attachment VARCHAR(255),
  channelId INTEGER NOT NULL,
  userId INTEGER NOT NULL,
  createdAt DATETIME NOT NULL,
  updatedAt DATETIME NOT NULL,
  FOREIGN KEY (channelId) REFERENCES Channels(id) ON DELETE CASCADE,
  FOREIGN KEY (userId) REFERENCES Users(id) ON DELETE CASCADE
);
```

## Authentication Flow

1. **Registration**:
   - Client submits username, email, password
   - Server validates input
   - Password is hashed
   - User record is created
   - JWT token is generated and returned

2. **Login**:
   - Client submits email, password
   - Server validates credentials
   - JWT token is generated and returned

3. **Authentication**:
   - Client includes JWT in Authorization header
   - Server validates JWT in middleware
   - User object is attached to request
   - Protected routes check for user object

## Real-time Messaging Flow

1. **Connecting**:
   - Client connects to Socket.IO with JWT
   - Server authenticates token
   - Client joins user-specific room

2. **Joining Channel**:
   - Client emits `channel:join` with channel ID
   - Server subscribes client to channel room
   - Server emits `channel:join` to all users in channel

3. **Sending Message**:
   - Client emits `message:send` with message content
   - Server validates and saves message to database
   - Server emits `message:new` to all users in channel
   - Message appears in real-time for all connected users

4. **Typing Indicator**:
   - Client emits `typing:start` when user begins typing
   - Server broadcasts `user:typing` to channel
   - Client emits `typing:stop` when user stops typing
   - Typing indicator disappears after timeout

## Testing Strategy

### Backend Testing
- Unit tests for controllers and models
- Integration tests for API endpoints
- Socket.IO event testing

### Frontend Testing
- Component tests with React Testing Library
- Integration tests for form submissions
- E2E tests for critical user flows

## Deployment Considerations

- Database migration strategy
- Environment configuration
- Static asset serving
- Production builds
- Containerization (Docker)
- WebSocket scaling (for multiple server instances)

## Security Considerations

- Password hashing with bcrypt
- JWT secret rotation
- Input validation and sanitization
- SQL injection prevention (via Sequelize)
- Rate limiting for authentication attempts
- XSS prevention
- CORS configuration

## Performance Optimizations

- Database indexing
- Connection pooling
- Message pagination
- Lazy loading of channel history
- Optimistic UI updates
- Caching strategies for frequently accessed data

## Next Steps and Enhancements

- Direct messaging between users
- User presence indicators
- Message reactions
- File uploads
- Voice/video chat integration
- Role-based permissions
